\documentclass[a4paper,10pt,openany,oneside]{report}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[francais]{babel}
\usepackage{eurosym}
\usepackage[margin=1.5in]{geometry}
\usepackage{graphicx}
\usepackage{fancyhdr}
\usepackage{xcolor}

\pagestyle{fancy}
\renewcommand{\headrulewidth}{0pt}

\setlength{\oddsidemargin}{0pt}
\setlength{\topmargin}{0pt}
\setlength{\marginparwidth}{0pt}
\setlength{\headheight}{30pt}
\setlength{\headwidth}{450pt}
\setlength{\headsep}{10pt}
\setlength{\voffset}{0pt}
\setlength{\hoffset}{0pt}
\setlength{\footskip}{70pt}
\setlength{\textwidth}{450pt}
\setlength{\textheight}{580pt}
\setlength{\parskip}{8pt}
\setlength{\parindent}{0pt}

\title{SYR DeaDBeeF - Projet SYR2 - Compte Rendu}
\author{Antoine \bsc{Pinsard}}
\date{12 Mars 2015}

\makeatletter
\lhead{\Large{\bf\@title}}
\lfoot{\footnotesize \color[gray]{0.5} \@title}
\rfoot{\footnotesize \color[gray]{0.5} \@author / \@date}
\makeatother

\renewcommand{\thesection}{\arabic{section}}

\begin{document}

\maketitle

\section{Un lecteur audio}

\subsection{Que se passe-t-il si on déclare une fausse fréquence
            d'échantillonnage à la sortie audio ?}

Lorsqu'on déclare une fréquence d'échantillonnage 2 fois plus grande, la
vitesse de lecture du son est multipliée par 2. Inversement, lorsqu'on déclare
une fréquence d'échantillonnage 2 fois plus petite, le fichier son est joué
deux fois plus lentement.

Plus la fréquence d'échantillonage est élevée, plus on a capturé d'informations
sur le son dans un interval de temps donné. Si on renseigne une fréquence x
fois plus élevée que la fréquence réelle, on va lire x fois plus d'informations
dans une même période de temps. Ce qui explique le phénomène observé.

\subsection{Que se passe-t-il si vous déclarez à la sortie audio que le fichier
            est mono ?}

Si on déclare que le fichier est en mono alors qu'il est en stereo, le son est
plus lent et plus grave. C'est le même effet que lorsqu'on lit une cassette
audio magnetique avec une vitesse de rotation plus faible que la normale.

\subsection{Que se passe-t-il si vous déclarez à la sortie audio une mauvaise
            taille d'échantillons ?}

Ça fait sursauter, enlever vite instinctivement les oreillettes, et baisser le
volume avant de remettre les écouteurs craintivement l'un après l'autre. On
entend alors un faible "pshhhh" dans l'oreille gauche et on parvient tout de
même à reconnaître la mélodie, jouée par un piano Fisher-Price dont les piles
sont en fin de vie, dans l'oreille droite.

\section{Streaming audio}

\subsection{Quelles informations doivent être transmises dans chaque
            datagramme ?}

Un premier datagramme doit contenir les headers du fichier audio :

\begin{itemize}
    \item taux d'échantillonnage
    \item taille des échantillons
    \item nombre de canaux
\end{itemize}

Ce premier datagramme contiendra également le nombre de paquets qu'il va
envoyer après celui-ci.

Les paquets suivants doivent contenir une partie du fichier, ainsi qu'un numéro
afin que le client soit en mesure de lire le fichier dans l'ordre et de se
rendre compte de l'absence d'un morceau.

\subsection{Que doit faire chaque programme quand il reçoit un tel message ?}

Quand le client reçoit les headers, il prépare un descripteur de fichier avec
les données reçues.

Quand il reçoit les autres paquets, il les assemble dans un tampon, en
respectant le numéro des paquets. S'il reçoit le dernier paquet, ou s'il n'a
pas reçu de paquets depuis 3 secondes, il s'arrête.

\subsection{Protocole de communication}

Le client doit envoyer un premier paquet contenant uniquement le nom du fichier
qu'il souhaite recevoir.

Si le serveur peut répondre à la demande du client, il envoie alors un premier
paquet de la forme :

\begin{verbatim}
OK <sample_rate> <sample_size> <channels> <nb_packets>
\end{verbatim}

\begin{itemize}
    \item <sample\_rate> (int) : Le taux d'échantillonnage en Hz ;
    \item <sample\_size> (int) : La taille des échantillons en octets ;
    \item <channels> (int) : Le nombre de canaux ;
    \item <nb\_packets> (int) : Le nombre de paquets à transmettre.
\end{itemize}

En cas d'erreur, il envoie un paquet d'erreur (voir ci-un peu plus bas) avec un
des codes suivants :

\begin{itemize}
    \item 790526 : Serveur occupé, redemander plus tard ;
    \item 57005 : Fichier introuvable ;
\end{itemize}

Les paquets suivants sont de la forme :

\begin{verbatim}
DAT <n> <data>
\end{verbatim}

\begin{itemize}
    \item <n> (int) : le numéro du packet
    \item <data> (bytes) : les données transmises
\end{itemize}

Afin d'éviter de perdre du temps à envoyer des données inutilement, le client
doit envoyer un packet \texttt{IMSTILLHERE} tous les 10 paquets reçus. Si le
serveur envoie 20 packets sans recevoir ce paquet de heartbeat, il envoie un
dernier paquet d'erreur avec le code \texttt{48807} puis arrête la
transmission.

Les paquets d'erreur sont de la forme :

\begin{verbatim}
ERR <code>
\end{verbatim}

\begin{itemize}
    \item <code> (int) : Un code d'erreur spécifiant la cause de l'erreur.
\end{itemize}

Les codes d'erreurs ont été détaillés ci-un peu plus haut dans les cas
concernés. Il existe cependant un dernier code d'erreur : \texttt{2989}. Ce
code d'erreur est renvoyé lorsqu'une requête est mal formée et n'a pas été
comprise par le serveur.

\end{document}
